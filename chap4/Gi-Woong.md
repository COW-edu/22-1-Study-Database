# 5주차 과제


1. 데이터 타입 조사(MySQL 8.0 기준)
2. 제약 조건 조사(MySQL 8.0 기준)
3. KEY 종류에 대해서 조사

# 데이터 타입

### **1. 숫자형**

### **1) 정수 유형**

| BIT(M) | 비트값 타입. 즉, 0과 1로 구성되는 binary 값을 저장한다.(M : 1~64, 생략 시 기본값은 1 로 설정) |
| --- | --- |
| BOOL | 0은 false, 0이 아닌 값은 true 로 간주하는 논리형 데이터ENUM(Y,N) 또는 TINYINT(1) 로 대체하여 사용하는 것을 권장 |
| TINYINT(M) | 부호 있는 수는 -128 ~ 127부호 없는 수는 0 ~ 225 까지 표현 (1바이트) |
| SMALLINT(M) | 부호 있는 수는 -32768 ~ 32767부호 없는 수는 0 ~ 65535 까지 표현 (2바이트) |
| MEDIUMINT(M) | 부호 있는 수는 -8388608 ~ 8388607부호 없는 수는 0 ~ 16777215 까지 표현 (3바이트) |
| INT(M), INTEGER(M) | 부호 있는 수는 -2147483648 ~ 2147483647부호 없는 수는 0 ~ 4294967295 까지 표현 (4바이트) |
| BIGINT(M) | 부호 있는 수는 -92233720036854775808 ~ 92233720036854775807부호 없는 수는 0~18446744073709551615 (8바이트) |

### **2) 고정 소수점 유형**

| DECIMAL(M,D) | M자리 정수(정밀도)와 D자리 소수점(스케일)으로 표현최대 65자리까지 표현할 수 있다. |
| --- | --- |

### **3) 부동 소수점 유형**

| FLOAT(M,D) | 정밀도가 작은 부동소수점을 표현. UNSIGNED 인 경우 음수 값을 허용하지 않는다.-3.402823466E+38 ~ 3.402823466E+38 |
| --- | --- |
| DOUBLE(M,D) | 보통 크기의 부동소수점을 표현. UNSIGNED 인 경우 음수 값을 허용하지 않는다.-1.7976931348623157E+308 ~ 1.7976931348623157E+308 |
- FLOAT, DOUBLE 등의 부동 소수점 유형은 MySQL 8.0.17 이후 버전부터 사용되지 않습니다.– 참고문서 : [MySQL 8.0 Reference > Problems with Floating-Point Values](https://dev.mysql.com/doc/refman/8.0/en/problems-with-float.html)

### **2. 날짜형**

| DATE | 날짜를 표현하는 타입 (3바이트)1000-01-01 ~ 9999-12-31 |
| --- | --- |
| DATETIME | 날짜와 시간을 같이 나타내는 타입 (8바이트)1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 |
| TIMESTAMP | 1970-01-01 00:00:00 ~ 2037-01-19 03:14:07INSERT, UPDATE 연산에 유리하다. (4바이트) |
| TIME | 시간을 표현하는 타입 (3바이트)-838:59:59 ~ 838:59:59 |
| YEAR | 연도를 나타낸다. (1바이트)1901 ~ 2155, 70 ~ 69 (1970~2069) |
- YEAR(4) 와 같이 명시적인 길이를 표기한 데이터 유형은 MySQL 8.0.19 이후 버전부터 사용되지 않습니다.
- YEAR(2) 와 같이 두 자리로 표기하는 데이터 유형은 MySQL 5.7 이후 버전부터 지원하지 않는다.
– 참고문서 : [MySQL 5.7 Reference > 2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR](https://dev.mysql.com/doc/refman/8.0/en/two-digit-years.html)

### **3. 문자형**

| CHAR(M) | 고정 길이를 가지는 문자열을 저장한다. (M : 0~255) |
| --- | --- |
| VARCHAR(M) | 가변 길이를 가지는 문자열을 저장하며, 후행 공백을 제거하지 않는다. (M : 0~65,535)M이 0~255 이면 문자길이+1byte, ~65,535 이면 문자길이+2byte |
| TINYBLOB, TINYTEXT | 1~255 개의 가변 길이를 가지는 문자열을 저장한다. (문자길이+1byte) |
| BLOBTEXT | 1~65,535 개의 가변 길이를 가지는 문자열을 저장한다. (문자길이+2byte)BLOB 는 바이너리 데이터, TEXT 는 문자 데이터 저장에 유리하다. |
| MEDIUMBLOB, MEDIUMTEXT | 1~16,777,215 개의 가변 길이를 가지는 문자열을 저장한다. (문자길이+3byte) |
| LONGBLOB, LONGTEXT | 1~429,496,729 개의 가변 길이를 가지는 문자열을 저장한다. (문자길이+4byte) |
| ENUM | 문자 형태인 value 를 숫자로 저장하여 최대 65,535 개의 문자열 중 한가지를 반환255 이하 value 는 1바이트, 65,535 이하 value 는 2바이트 |
| SET | 비트 연산 열거형, ENUM 형과 동일하게 문자열 값을 정수값으로 매핑하여 저장한다. |
- ENUM 은 반드시 하나의 값만 저장되며, SET 은 다중 선택이 가능gk다.

ref: [https://devdhjo.github.io/mysql/2020/01/30/database-mysql-003.html](https://devdhjo.github.io/mysql/2020/01/30/database-mysql-003.html)

# 제약조건

제약조건: 데이터의 무결성을 지키기 위해, 데이터를 입력받을 때 실행하는 검사규칙

## NOT NULL

NOT NULL 제약조건을 설정한 필드는 NULL 값을 저장할 수 없음

→ 이 제약 조건이 설정된 필드는 무조건 데이터를 가지고 있어야 함.

## UNIQUE

- UNIQUE 제약조건이 설정된 필드는 서로 다른값(유일값)을 가져야 함.

→ 이 제약조건이 설정된 필드는 중복된 값을 저장할 수 없음.

- 한 테이블에 있는 여러 필드에 UNIQUE제약조건을 설정할 수 있음.

## PRIMARY KEY

- NOT NULL과 UNIQUE의 특징을 모두 가지는 제약조건
- 따라서 PRIMARY KEY 제약 조건을 가진 필드는 NULL값을 가질 수 없으며, 중복값을 가질 수도 없음.
- 또 UNIQUE와는 달리 한 테이블 당 하나의 필드에만 PRIMARY KEY 제약조건을 설정할 수 있음.

## FOREIGN KEY

- FOREIGN KEY 제약조건을 설정한 필드를 **왜래 키**라고도 부름.
- 한 테이블과 다른 테이블을 **연결**🔗시켜주는 역할을 함.
- 외래 키가 설정된 테이블에 레코드(기록 내용)를 입력하면, 기준이 되는 테이블의 내용을 참조해서 레코드가 입력된다.
- 즉, FOREIGN KEY 제약 조건은 하나의 테이블을 다른 테이블에 **의존**하게(관계를 가지게) 한다.
- FOREIGN KEY 제약 조건을 설정할 때 참조되는 테이블의 필드는 반드시 **UNIQUE나 PRIMARY KEY 제약 조건이 설정**되어 있어야 한다.

ref: [https://dev-coco.tistory.com/55](https://dev-coco.tistory.com/55)

## DEFAULT

DEFAULT 제약조건은 해당 필드의 기본값(기본으로 저장하는 값(value))을 설정할 수 있게 해줌.

만약 레코드를 입력할 때 해당 필드에 값을 전달하지 않으면, 자동으로 설정된 기본값으로 그 필드에 값을 저장함.

ref: [http://www.tcpschool.com/mysql/mysql_constraint_notNull](http://www.tcpschool.com/mysql/mysql_constraint_notNull)

# KEY 종류

### KEY

키(Key)

- Key: **무언가를 식별하는 고유한 식별자**(identifier) 역할을 하는 것(object).
- 즉, 키는 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 순서대로 정렬할 때 다른 행과 구별할 수 있는 유리한 기준이 되는 속성의 집합이다.
- 키의 종류로는 기본키, 슈퍼키, 후보키, 대체키, 외래키 등이 있다.

### 최소성과 유일성

유일성: 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질

최소성 : 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질

여기서 **튜플** 이란 데이터베이스내의 주어진 목록과 관계있는 속성값의 모음이다.

### KEY 종류

![image](https://user-images.githubusercontent.com/77622897/162134577-6f73b74e-ae3b-43b0-be9e-bc0f231f534b.png)

- **복합 키(Composite Key)**: **2개 이상**의 속성(attribute)를 사용한 키.
- **슈퍼 키(Super Key)**: **유일성**을 만족하는 키.
    - 고유의 ID 역할을 하는 데이터가 포함되어서 unique함을 유지하는 키라고 생각하면 됨.
    - **어떤 속성끼리 묶던 중복값이 안나오고 서로 구별**
    만 할 수 있으면 된다.
    - ex) {학번 + 이름}, {주민등록번호 + 학번}
- **후보 키(Candidate key)**: **유일성**과 **최소성**을 만족하는 키.
    - 기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다.
    - 슈퍼키들 중에서 속성을 **최소한의 갯수**로 묶어서 유일성을 만족해야 한다.
    - ex) 주민등록번호, 학번 등
- **기본 키(Primary key)**: 후보 키에서 선택된 키.
    - NULL값이 들어갈 수 없음.
    - 기본키를 구성하는 모든 속성은 null 값을 가질 수 없음.
    - 기본키로 선택된 속성(Attribute)은 동일한 값이 들어갈 수가 없다.
    - 최소성과 유일성을 만족해야 함.
    - 테이블에서 기본키는 **오직 1개**만 지정할 수 있음.
    - 기본키(로 지정된 속성)는 **NULL 값을 절대 가질수 없고, 중복된 값을 가질 수 없다**.
- **대체 키(Surrogate key)**: 후보 키 중에 기본 키로 선택되지 않은 키.
    - 기본키는 하나만 지정할 수가 있기 때문에 하나가 기본키로 지정되면 지정되지 않은 남은 후보키들은 자동으로 대체키가 됨.
- **외래 키(Foreign Key):** 어떤 테이블(Relation) 간의 기본키(Primary key)를 참조하는 속성이다.
    - 다른 테이블의 기본 키를 참조하는 키이다.
    - 외래 키는 참도죄는 테이블의 기본키와 동일한 키 속성을 지닌다.
    - 외래키는 참조할 수 없는 값을 가질 수 없다.
        - 왜?) 기본키를 참조하는데 기본키는 NULL값(참조할 수 없는 값)을 가질 수 없으니까.
    - 테이블들 간의 관계를 나타내기 위해서 사용된다.

ref: 

[https://jerryjerryjerry.tistory.com/49](https://jerryjerryjerry.tistory.com/49)

[https://kosaf04pyh.tistory.com/201](https://kosaf04pyh.tistory.com/201)

[https://inpa.tistory.com/entry/DB-📚-키KEY-종류-🕵️-정리](https://inpa.tistory.com/entry/DB-%F0%9F%93%9A-%ED%82%A4KEY-%EC%A2%85%EB%A5%98-%F0%9F%95%B5%EF%B8%8F-%EC%A0%95%EB%A6%AC)
