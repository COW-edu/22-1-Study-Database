# MySQL 데이터 타입
## 정수타입
- TINYINT : 1 바이트
- SMALLINT : 2 바이트
- MEDIUMINT : 3 바이트
- INT : 4 바이트 
- BIGINT : 8 바이트 
- DECIMAL : 가변
- FLOAT : 4 바이트
- DOUBLE : 8 바이트 

정수를 저장할 거라면 정수(integer) 타입인 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 중 하나를 사용할 수 있다. 이 타입들은 8, 16, 24, 32, 64 비트의 저장 공간이 필요하다. 정수 타입에는 UNSIGNED (부호 없음) 속성을 사용할 수도 있으며, 이 속성은 음수 값을 허용하지 않는 대신 저장 가능한 양수 값의 한도를 거의 두 배로 늘려준다.

어떤 데이터 타입을 골랐느냐에 따라 MySQL에서 데이터를 메모리 나 디스크에 저장하는 방식이 결정된다. 하지만 32비트 아키텍처라도 정수를 계산할 땐 보통 64비트 BIGINT 정수를 사용한다(일부 집합 함수는 예외적으로 DECIMAL이나 DOUBLE을 사용한다)

MySQL에선 INT(11)과 같이 정수 타입의 ‘길이’를 명시할 수 있다. 하지만 이 기능은 값의 유효 범위를 제한하진 않고, MySQL 클라이언트 같은 프로그램의 화면 출력용으로 예약하는 문자의 개수를 지정할 뿐이므로 대부분의 응용프로그램에 선 별다른 의미가 없다. 저장이나 계산 측면에서 INT(1)은 INT(20)과 동일하다.

## 실수타입
실수는 소수부가 있는 숫자다. 하지만 단지 소수부 때문에 실수가 있는 건 아니다. BIGINT로 표현할 수 없을 만큼 큰 정수도 DECIMAL을 이용하면 저장 가능하다. MySQL에서는 정확한 타입과 부정확한 타입을 모두 지원한다.
- DECIMAL 
    - 고정소수점 (소수부의 자릿수를 미리 정하여 고정된 자릿수의 소수를 표현하는 것. 정수부와 소수부로 나눔.)
    - 소수부를 정확하게 저장하는 용도로 사용
    - DECIMAL(M,D)
        - M은 소수 부분을 포함한 실수의 총 자릿수를 나타내며 최대값은 65
        - D는 소수 부분의 자릿수를 나타내며, D가 0이면 소수 부분을 가지지 않음
- DOUBLE
    - 부동소수점 (가수부와 지수부로 나눔. 매우 큰 실수까지도 표현할 수 있음.)
    - 대략적인 숫자 데이터 값(근사값)을 표현할 때 사용
    - DOUBLE(M,D)
        - M은 소수 부분을 포함한 실수의 총 자릿수
        - D는 소수 부분의 자릿수

## 문자열 타입
MySQL은 문자열 데이터 타입을 몇 가지 밖에 지원하지 않지만 각 타입마다 여러 가지 변형이 있으며 특히 VARCHAR 타입과 CHAR 타입의 서로 다른 특징을 파악해두면 MySQL 최적의 데이터 타입 선택 방법 에 도움이 될 것으로 보여진다.

- VARCHAR
    - 가변 길이의 문자열을 저장하는 가장 흔한 문자열 데이터 타입
    - 필요한 만큼만 공간을 사용하기에 고정 길이 타입보다 저장 공간을 적게 사용하기도 한다.
    - 공간을 절약하므로 성능에 도움이 되지만 행이 가변 길이이므로 행을 업데이트할 때 행의 길이가 길어지기도 하며, 이러한 이유로 추가적인 작업이 필요할 수도 있다.
    - 보통 컬럼의 최대 길이가 평균 길이보다 훨씬 클 때나 필드가 업데이트되는 일이 드물어서 단편화가 문제되지 않을 때 혹은 UTF-8 처럼 문자마다 사용하는 바이트 수가 다른 복잡한 문자 셋을 사용할 때 유용하다.
- CHAR
    - 고정 길이이므로 MySQL에서는 항상 지정된 문자 개수에 맞춰 충분한 공간을 할당한다.
    - 아주 짧은 문자열을 저장하고자 할 때나 모든 값이 거의 같은 길이일 때 유용하다. 예를 들면 MD5의 경우 값의 길이가 언제나 같기 때문에 이 값을 저장할 땐 CHAR가 적합하다. 고정 길이의 행은 단편화가 거의 발생하지 않으므로 자주 바뀌는 데이터를 저장할 때라면 CHAR가 VARCHAR보다 유리하다.
    - 아주 짧은 컬럼에도 CHAR를 사용하는 것이 VARCHAR를 사용하는 것보다 효율적이다. Y와 N값만 저장하는 것처럼 한 바이트짜리 문자 셋이라면 CHAR(1)은 1바이트만 사용하지만 VARCHAR(1)에선 길이 바이트 때문에 2바이트를 쓴다.

## BLOB 타입과 TEXT 타입
- BLOB 및 TEXT 군의 유일한 차이점이라곤 BLOB 타입은 문자 셋이나 콜레이션이 없는 바이너리 데이터를 저장하는 반면, TEXT 타입은 문자 셋과 콜레이션이 있는 텍스트 데이터를 저장한다는 것이다.
- BLOB – 바이너리 형식 (TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB)
- TEXT – 텍스트 형식 (TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT)

## 날짜 및 시간 타입
MySQL은 날짜와 시간 값에 쓰는 데이터 타입이 다양하다. MySQL이 저장할 수 있는 가장 작은 시간 단위는 1초이지만 시간 연산은 마이크로초 단위로 수행 가능하다.
- DATE
- DATETIME
- TIMESTAMP
- TIME
- YEAR

- DATETIME
    - 날짜와 시각을 표현하는 ANSI 표준 방식
    - 1001년부터 9999년까지의 값을 1초 단위로 저장할 수 있으며, 날짜와 시각을 YYYYMMDDHHMMSS 포멧의 정수 값으로 묶는데 시간대에는 영향을 받지않는다.
    - DATETIME은 8바이트의 저장 공간을 사용한다.
- TIMESTAMP
    - TIMESTAMP 타입은 1970년 1월 1일 자정(그리니치 평균시)을 기준으로 몇 초가 지났는지를 저장하며, Unix 타임스탬프와 동일하다.
    - TIMESTAMP는 저장 공간을 4바이트 사용하므로 값의 범위가 DATETIME보다 훨씬 작고, 1970년 ~ 2038년 사이의 값만 저장할 수 있다.
    - MySQL에서 TIMESTAMP 컬럼에 값을 지정하지 않은 채로 행을 추가하면 첫 번째 TIMESTAMP 컬럼에 현재 시작을 넣는다. 또 UPDATE문에 업데이트 할 첫 번째 TIMESTAMP 값을 명시적으로 할당하지 않은 채로 행을 업데이트 하면 TIMESTAMP 컬럼의 값을 자동으로 업데이트한다.
    - 다른 데이터 타입과는 달리 TIMESTAMP 컬럼은 기본적으로 NOT NULL 이다.

## 비트 데이터 타입
- Bit 타입은 비트의 값을 저장하며 0과 1로 구성되는 바이너리(Binary) 값을 저장할 수 있다.
- Bit(M) : M의 범위는 1 부터 64까지 설정할 수 있으며, 명시한 M 비트의 값을 저장할 수 있다.
- MySQL은 Bit를 숫자 타입이 아닌 문자열 타입으로 취급한다. bit(1) 값을 조회하게 되면 그 결과 타입도 문자열이지만 내용물은 바이너리 값인 0이나 1이지 ASCII 값인 “0”이나 “1”이 아니다. 하지만 값을 숫자 기반으로 조회한다면 비트 문자열이 변환된 숫자가 결과로 나온다.

# MySQL 제약조건
제약조건(constraint)이란 데이터의 무결성을 지키기 위해, 데이터를 입력받을 때 실행되는 검사 규칙을 의미한다.

이러한 제약 조건은 CREATE 문으로 테이블을 생성할 때나 ALTER 문으로 컬럼을 추가할 때도 설정할 수 있다.

## NOT NULL
NOT NULL 제약 조건을 설정하면, 해당 필드는 NULL 값을 저장할 수 없다. 즉, 이 제약 조건이 설정된 필드는 무조건 데이터를 가지고 있어야 한다.

문법
```
CREATE TABLE 테이블이름
(
    필드이름 필드타입 NOT NULL,
    ...
)
```

## UNIQUE
UNIQUE 제약 조건을 설정하면, 해당 필드는 서로 다른 값을 가져야한다. 즉, 이 제약조건이 설정된 필드는 중복된 값을 저장할 수 없다. 

문법
```
1. CREATE TABLE 테이블이름
(
    필드명 필트타입 UNIQUE,
    ...
)

2. CREATE TABLE 테이블이름
(
    필드이름 필드타입,
    ...,
    [CONSTRAINT 제약조건이름] UNIQUE (필드이름)
)
```

## PRIMARY KEY
PRIMARY KEY 제약 조건을 설정하면, 해당 필드는 NOT NULL과 UNIQUE 제약 조건의 특징을 모두 가진다. 따라서 이 제약조건이 설정된 필드는 NULL 값을 가질 수 없으며, 또한 중복된 값을 가질 수 없다. 이러한 PRIMARY KEY 제약 조건을 기본 키라고 한다. 테이블의 데이터를 쉽고 빠르게 찾도록 도와주는 역할을 한다.

문법
```
1. CREATE TABLE 테이블이름
(
    필드명 필트타입 PRIMARY KEY,
    ...
)

2. CREATE TABLE 테이블이름
(
    필드이름 필드타입,
    ...,
    [CONSTRAINT 제약조건이름] PRIMARY KEY (필드이름)
)
```

## FOREIGN KEY
FOREIGN KEY 제약 조건을 설정한 필드를 외래 키라고 부르며, 한 테이블을 다른 테이블과 연결해주는 역할을 한다. 외래 키가 설정된 테이블에 레코드를 입력하면, 기준이 되는 테이블의 내용을 참조해서 레코드가 입력된다. 즉, FOREIGN KEY 제약 조건은 하나의 테이블을 다른 테이블에 의존하게 만든다. OREIGN KEY를 설정할 때 참조되는 테이블의 필드는 반드시 UNIQUE나 PRIMARY KEY가 설정되어 있어야 한다.

문법
```
CREATE TABLE 테이블이름 
( 
    필드이름 필드타입, 
    ..., 
    [CONSTRAINT 제약조건이름] 
    FOREIGN KEY (필드이름) 
    REFERENCES 테이블이름 (필드이름)
)
```

## DEFAULT
DEFAULT 제약 조건은 해당 필드의 기본값을 설정할 수 있게 해준다. 만약 레코드를 입력할 때 해당 필드 값을 전달하지 않으면, 자동으로 설정된 기본 값을 저장한다.

문법
```
CREATE TABLE 테이블이름 
( 
    필드이름 필드타입 DEFAULT 기본값, 
    ... 
)
```

# KEY 종류
![ex_screenshot](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F74FZR%2FbtqClyMJ0sx%2Fay7x7W2V3cWukTMoyYHp51%2Fimg.png)
- 슈퍼 키(Super Key) : 유일성을 만족하는 키. 예를 들면, {학번 + 이름}, {주민등록번호 + 학번}
- 복합 키(Composite Key) : 2개 이상의 속성(attribute)를 사용한 키.
- 후보 키(Candidate key) : 유일성과 최소성을 만족하는 키. 기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다. 예를 들면, 주민등록번호, 학번 등
- 기본 키(Primary key) : 후보 키에서 선택된 키. NULL값이 들어갈 수 없으며, 기본키로 선택된 속성(Attribute)은 동일한 값이 들어갈 수가 없다.
- 대체 키(Surrogate key) : 후보 키 중에 기본 키로 선택되지 않은 키.
- 외래 키(Foreign Key) : 어떤 테이블(Relation) 간의 기본 키(Primary key)를 참조하는 속성이다. 테이블(Relation)들 간의 관계를 나타내기 위해서 사용된다.

유일성 : 하나의 키 값으로 튜플을 유일하게 식별할 수 있는 성질  
최소성 : 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질  
<<<<<<< HEAD
튜플 : 셀 수 있는 순서 있는 열거  
=======
튜플 : 셀 수 있는 순서 있는 열거
>>>>>>> 2d78e8425ab530ccf056d7fb7393bd3110176146
