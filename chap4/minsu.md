# 1. 데이터 타입 조사(MySQL 8.0 기준)
## 숫자타입
### 정수타입

|데이터타입 |signed|unsigned| 바이트|
|:---:|:---:|:---:|:---:|
|TINYINT|-128 ~ 127|0 ~ 255|1바이트|
|SMALLINT|	-32768 ~ 32767|	0 ~ 65535	|2 바이트|
|MEDIUMINT|	-8388608 ~ 8388607	|0 ~ 16777215|	3 바이트|
|INT|	-2147483648 ~ 2147483647|	0 ~ 4294967295|	4 바이트|
|BIGINT|	-9223372036854775808~ 9223372036854775807|	0~18446744073709551615|	8 바이트|
### 고정소수점
|데이터타입|범위|바이트|
|:---:|:---:|:---:|
|DECIMAL|전체자리수(precision)와 소수점자리수(scale)를 가짐 |가변|
|NUMBER| |가변|

### 부동소수점
|데이터타입|범위|바이트|
|:---:|:---:|:---:|
|FLOAT|	-3.402823466×1038 ~ 3.402823466×1038|	4 바이트|
|DOUBLE|	-1.7976931348623157×10308 ~ 1.7976931348623157×10308|	8 바이트|


- 부호없는 정수(양수)만 데이터 타입을 지정할 수 있는데 선언 시 UNSIGNED 예약어만 뒤에 붙여주면 된다

- 부동소수점 타입과 고정소수점  타입의 차이는 부동소수점은 FLOAT는 소수점 7자리 DOUBLE은 15자리까지 표현하고 고정소수점은 scale을 가지고 있어 원하는 소수점 자리 까지 저장한다.

## 문자열타입
- VARCHAR
    - 가변 길이의 문자열을 저장하는 가장 흔한 문자열 데이터 타입 
    - 필요한 만큼만 공간을 사용하기에 고정 길이 타입보다 저장 공간을 적게 사용하기도 한다. 
    - 공간을 절약하므로 성능에 도움이 되지만 행이 가변 길이이므로 행을 업데이트할 때 행의 길이가 길어지기도 하며, 이러한 이유로 추가적인 작업이 필요할 수도 있다.
    - 보통 컬럼의 최대 길이가 평균 길이보다 훨씬 클 때나 필드가 업데이트되는 일이 드물어서 단편화가 문제되지 않을 때 혹은 UTF-8 처럼 문자마다 사용하는 바이트 수가 다른 복잡한 문자 셋을 사용할 때 유용하다.
- CHAR
    - 고정 길이이므로 MySQL에서는 항상 지정된 문자 개수에 맞춰 충분한 공간을 할당한다.
    - 아주 짧은 문자열을 저장하고자 할 때나 모든 값이 거의 같은 길이일 때 유용하다. 예를 들면 MD5의 경우 값의 길이가 언제나 같기 때문에 이 값을 저장할 땐 CHAR가 적합하다. 고정 길이의 행은 단편화가 거의 발생하지 않으므로 자주 바뀌는 데이터를 저장할 때라면 CHAR가 VARCHAR보다 유리하다.
    - 아주 짧은 컬럼에도 CHAR를 사용하는 것이 VARCHAR를 사용하는 것보다 효율적이다. Y와 N값만 저장하는 것처럼 한 바이트짜리 문자 셋이라면 CHAR(1)은 1바이트만 사용하지만 VARCHAR(1)에선 길이 바이트 때문에 2바이트를 쓴다.
    예를들어 ‘good’ 값을 저장하면 VARCHAR(4) 컬럼이든 VARCHAR(100) 컬럼이든 같은 공간을 차지한다. 하지만 MySQL 에서 내부적으로 값을 저장할 때 고정 크기의 메모리를 할당하므로 큰 컬럼을 사용하면 메모리를 더 많이 사용하게 될수도 있다. 그러면 메모리 안에 있는 임시 테이블을 사용하는 연산이나 정렬이 필요한 경우 성능이 안 좋을 수 있다. 그러므로 가장 좋은 방법은 필요한 만큼만 공간을 할당하는 것이다.

- BLOB 타입과 TEXT 타입
    - BLOB 및 TEXT 군의 유일한 차이점이라곤 BLOB 타입은 문자 셋이나 콜레이션이 없는 바이너리 데이터를 저장하는 반면, TEXT 타입은 문자 셋과 콜레이션이 있는 텍스트 데이터를 저장한다는 것이다.
     - BLOB – 바이너리 형식 (TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB)
    - TEXT – 텍스트 형식 (TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT)


# 2. 제약 조건 조사(MySQL 8.0 기준)
- 기본키 제약 조건
    - 기본키(PRIMARY KEY) 입력값은 중복될 수 없고 NOT NULL이다.

- 외래키 제약 조건
    - 두 테이블 사이의 관계를 선언해서 데이터의 무결성을 보장

    - 테이블 사이에 외래키 설정시 한 테이블이 다른 테이블에 의존한다.

    - 외래키 테이블 : 외래키 정의 테이블

    - 기준 테이블 : 외래키에 의해 참조 되는 테이블

    - 외래키 테이블이 참조하는 기준 테이블의 열은 반드시 기본키(PK) , UNIQUE 제약조건이 설정되어 있어야 한다.


- UNIQUE 제약 조건
    중복되지 않는 유일한 값을 입력해야 하는 조건이다.

    - 기본키 제약 조건과 비슷하지만 NULL값을 허용한다.


- DEFAULT 제약 조건
    - 값을 입력하지 않았을 때 자동으로 입력되는 기본값을 정의

- NULL 값 허용
    - 테이블 정의할 때 NULL 값 입력을 허용하려면 NULL로 설정, 허용하지 않으려면 NOT NULL 설정

    - 기본키에는 NULL값이 올 수 없으므로 자동으로 NOT NULL 인식 



# 3. KEY 종류에 대해서 조사
## key 
데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.

### 기본키(Primary Key)
후보키 중에서 특별히 선정된 키로 중복된 값을 가질 수 없다.

후보키의 성질을 갖는다. 즉, 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키이며 NULL 값을 가질 수 없다. 즉, 튜플에서 기본키로 설정된 속성에는 NULL 값이 있어서는 안된다.

## 슈퍼키(Super Key)
한 릴레이션 내에 있는 속성들의 집합으로 구성된 키.
릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.
릴레이션을 구성하는 모든 튜플에 대해 유일성(Unique)은 만족하지만, 최소성(Minimality)은 만족하지 못한다.

### 대체키(Alternate Key)
후보키 중에서 선정된 기본키를 제외한 나머지 후보키를 의미한다.

예시 : 학생 릴레이션에서 학번이 기본키로 설정되면 주민등록번호는 대체키가 된다.

### 후보키(Candidate Key)
릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합.
유일성과 최소성을 모두 만족.

### 외래키(Foreign Key)
다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미

릴레이션 간의 관계를 표현할 때 사용하며 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의 되었을 때의 속성 A를 외래키라고 한다.

참조 릴레이션의 기본키와 동일한 키 속성을 가진다.

## 용어 정의
### 유일성
    키값으로 하나의 튜플만을 유일하게 식별할수있어야한다.
### 최소성
    키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 한다.