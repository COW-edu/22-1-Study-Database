# Chap3. 데이터베이스와 아키텍처 구성
견고하고 고속의 시스템을 구축하기 위해

## 과제
없음.


## 웹 3계층

### 프레젠테이션(클라이언트) 계층
- 프리젠테이션 계층은 일반 사용자가 애플리케이션과 상호작용하는 애플리케이션의 사용자 인터페이스 및 통신 계층입니다. 주요 목적은 정보를 표시하고 사용자로부터 정보를 수집하는 것입니다. 이 최상위 레벨 계층은 예를 들어 웹 브라우저, 데스크탑 애플리케이션 또는 그래픽 사용자 인터페이스(GUI)에서 실행될 수 있습니다. 웹 프리젠테이션 계층은 일반적으로 HTML, CSS 및 JavaScript를 사용하여 개발됩니다. 데스크탑 애플리케이션은 플랫폼에 따라 다양한 언어로 작성될 수 있습니다.

### 어플리케이션 계층
- 논리 계층 또는 중간 계층라고도 하는 애플리케이션 계층은 애플리케이션의 핵심입니다. 이 계층에서는 프리젠테이션 계층에서 수집된 정보가 처리됩니다. 때때로 이는 데이터 계층의 다른 정보에 대해 처리되며, 비즈니스 규칙의 특정 세트인 비즈니스 로직을 사용합니다. 또한 애플리케이션 계층은 데이터 계층의 데이터를 추가, 삭제 또는 수정할 수도 있습니다.

### 데이터베이스 계층
- 종종 데이터베이스 계층, 데이터 액세스 계층 또는 백엔드라고도 불리는 데이터 계층은 애플리케이션이 처리하는 정보가 저장 및 관리되는 곳입니다. 이는 관계형  데이터베이스 관리 시스템(예: PostgreSQL, MySQL, MariaDB, Oracle, DB2, Informix 또는 Microsoft SQL Server) 또는 비-SQL 데이터베이스 서버(예: Cassandra, CouchDB 또는 MongoDB)일 수 있습니다. 

### 장점
- 기능의 논리적 및 물리적 분리
- 각 계층은 별도의 운영체제 및 서버 플랫폼에서 실행될 수 있음.
- 각 계층이 하나 이상의 전용 서버 하드웨어 또는 가상 서버에서 실행되므로, 다른 티어에 영향을 주지 않고도 각 계층의 서비스를 사용자 정의하고 최적화할 수 있습니다. 

- 보다 신속한 개발: 각 계층이 서로 다른 팀에서 동시에 개발될 수 있으므로, 기업은 애플리케이션을 보다 빠르게 시장에 출시할 수 있으며 프로그래머는 각 계층에 대해 최신 및 최상의 언어와 툴을 사용할 수 있습니다.
- 확장성 개선: 필요에 따라 임의의 계층을 다른 계층과 독립적으로 확장할 수 있습니다.
- 안정성 향상: 한 계층의 가동 중단은 다른 계층의 가용성 또는 성능에 별로 영향을 미치지 않습니다.
- 보안성 강화: 프리젠테이션 계층과 데이터 계층이 직접 통신할 수 없으므로, 잘 설계된 애플리케이션 계층은 내부 방화벽의 일종으로 작동하여 SQL 인젝션 및 기타 악의적 행위를 방지할 수 있습니다.


## DB 아키텍처


### 용어
> 1. 가용성(Availability): 끊김 없이 서비스를 제공할 수 있는 능력  
>-> 서버가 고장나도 서비스를 제공되어야 한다.
> 2. 성능(Performance): 빠른 응답 시간과 낮은 레이턴시(지연시간)  
>-> 사용자의 요청에 대한 응답을 빠르게 한다.
> 3. 신뢰성(Reliability): 내부적인 결함이 발생하더라도 지속적으로 올바르게 동작  
>-> 장애가 발생해도 내 계좌 잔액은 틀리면 안된다.
> 4. 확장성(Scalability): 서버의 부하가 증가할 경우 대처할 수 있는 능력  
>-> 수강신청할 때 서버가 맛 안가게 해야한다.
> 5. 관리성(Manageability): 유지, 보수, 개선이 용이한 정도  
>-> 문제 생기면 어딘 지 바로 알 수 있어야 한다.
> 6. 비용(Cost): 시스템을 위한 모든 돈.  
>-> 위에 것들을 싼 값으로 해결한다.  
> ref = https://d2.naver.com/helloworld/206816

> Scale Out / Scale Up  
> Scale Out : 서버의 대수를 늘린다.  
> Scale Up : 서버의 성능을 올린다.

### DB의 가용성을 높히자(정지 하지 않는 시스템)

1. 심장 전략(고품질-소수)
  - 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제
2. 신장 전략(저품질-다수)
  - 각 컴포넌트는 "언제가 망가진다"는 전제를 가지고 여분 준비

- 현재는 거의 신장 전략 노선이 대세!

#### 클러스터
- 심장 전략처럼 동일한 기능의 컴포넌트를 병렬화 하는 것이 "클러스터링(Clustering)"
> 만약 서버의 고장률이 10%라면?  
'적어도 1대가 동작하고 있으면 서비스를 계쏙할 수 있다고 간주'  
서버가 늘어나면 고장률 곱!  
ex) 서버 1대 : 10%, 서버 2대 : 10% * 10% = 1%, 서버 3대 : 1% * 10% = 0.1%  


### DB 서버의 다중화
- DB 서버는 다중화가 어렵다?
- DB서버가 데이터를 보존하는 영속(Persistence) 계층이기 때문에
- 데이터는 항상 갱신 되기 때문에 다중화를 유지하는 중에 "데이터 정합성"도 중요하게 의식

#### 기본적인 다중화
- DB서버는 다중화, 저장소는 1개
- 정합성은 저장소가 1개라 신경 x
- 서버는 둘 다 동작? 혼자 동작?
  - Active-Active : 둘 다 동작
  - Active-Standby : 하나 동작, 하나 대기
##### Active-Active
- 가능한 저장소  
  => Oracle: RAC(Real Application Clusters)  
  => DB2 : pureScale
- 장점
  - 시스템 다운 시간이 짧다.
    - 하나 죽어도 하나가 동작 중이라 사용자한테는 계속 서비스 제공 가능
  - 성능 증가
    - 서버 처리를 위한 하드웨어 2배로 증가함.
    - 성능이 2배는 아님.
##### Active-Standby
- Cold-Standby
  - Active DB가 다운 된 시점에서 작동
- Hot-Standby    
  - 평소에도 작동 중
  - 훨씬 비쌈(Active-Active보단 쌈)

### Replication(복제)
- 데이터 저장소의 다중화
- 달걀을 한 바구니에 담지 마라!
- 재난에 대한 대응책
- 상용 서비스
  - Oracle : Data Guard
  - DB2 : HADR
  - MySQL : Replication
- Active쪽 데이터 갱신을, Standby쪽으로 동기화 해줘야함.
  - 이 동기화 주기가 성능과 트레이드 오프 관계
- Master-Slave(주인-노에?)
  - 일반적으로 Active되는 데이터베이스쪽을 Master, Standby 데이터베이스쪽을 Slave라고 하는데, 그 이유는 양쪽이 모두 Master인 케이스가 있어서 이와 구분하기 위해서임.
  - 하지만 매우 복잡한 구성이기 때문에 일반적으로 Replication이라고 하면 Master-Slave 방식이라고 생각하면 됨.
  - 용어에 대한 이야기(비인도적, 차별적 용어)
    - 마스터 슬레이브라는 단어의 뜻이 인종 차별적 용어이기 때문에 master를 Primary, Main으로 slave는 secondary, replica
### Shading
- Shard Noting : 아무것도 공유하지 않는다.
- 각 데이터 저장소가 아무 것도 공유하지 않고 각자의 저장소를 가짐
- 한 데이터에 접근할 수 있는 서버는 1대
- 서버가 죽으면 데이터에 접근 못함.
- 커버링(Covering) 필요.

## 정리
- 데이터베이스의 구조를 한번 정하면 바꾸기 어렵다.
![image](https://user-images.githubusercontent.com/61923768/161017874-0c97b6f5-b2e6-48e5-97b8-29f066a34c80.png)
